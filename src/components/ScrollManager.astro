---
export interface Props {
  sectionIds: string[];
}

const { sectionIds } = Astro.props;
---

<!-- Progress indicator -->
<div class="fixed right-4 top-1/2 transform -translate-y-1/2 space-y-3" aria-hidden="true" id="progress-dots" style="z-index: 50;">
  {sectionIds.map((sectionId, index) => (
    <div 
      id={`dot-${index}`} 
      class={`w-3 h-3 rounded-full transition-all duration-300 border border-secondary-light/30 cursor-pointer ${
        index === 0 ? 'bg-secondary-light shadow-lg' : 'bg-secondary-light/20'
      }`}
      data-section={sectionId}
    ></div>
  ))}
</div>

<script define:vars={{ sectionIds }}>
  document.addEventListener('DOMContentLoaded', function() {
    // Safari mobile detection and auto-scroll for main window
    const isSafariMobile = /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent) && !/CriOS|FxiOS|OPiOS|mercury/.test(navigator.userAgent);
    
    if (isSafariMobile) {
      // Wait for page to fully load, then scroll down 50% of the main window
      setTimeout(() => {
        const documentHeight = Math.max(
          document.body.scrollHeight,
          document.body.offsetHeight,
          document.documentElement.clientHeight,
          document.documentElement.scrollHeight,
          document.documentElement.offsetHeight
        );
        const windowHeight = window.innerHeight;
        const maxScroll = documentHeight - windowHeight;
        const targetScroll = Math.min(maxScroll * 0.80, maxScroll);
        
        window.scrollTo({
          top: targetScroll,
          behavior: 'smooth'
        });
      }, 500); // Longer delay to ensure everything is loaded
    }
    
    const scrollContainer = document.getElementById('scroll-container');
    const totalSections = sectionIds.length;
    const dots = [];
    let sectionElements = [];
    let sectionOffsets = [];
    
    // Get all dots dynamically
    for (let i = 0; i < totalSections; i++) {
      dots.push(document.getElementById(`dot-${i}`));
    }

    // Get all section elements and calculate their offsets
    function calculateSectionOffsets() {
      sectionElements = sectionIds.map(id => document.getElementById(id));
      sectionOffsets = [];
      
      sectionElements.forEach(section => {
        if (section) {
          sectionOffsets.push(section.offsetTop);
        }
      });
    }

    // Find the current section based on scroll position
    function getCurrentSection(scrollTop) {
      let currentSection = 0;
      
      for (let i = sectionOffsets.length - 1; i >= 0; i--) {
        if (scrollTop >= sectionOffsets[i] - 100) { // 100px offset for better UX
          currentSection = i;
          break;
        }
      }
      
      return currentSection;
    }

    function updateProgressDots() {
      const scrollTop = scrollContainer.scrollTop;
      const currentSection = getCurrentSection(scrollTop);
      
      // Update dot appearance based on current section
      dots.forEach((dot, index) => {
        if (index === currentSection) {
          dot.classList.remove('bg-secondary-light/20');
          dot.classList.add('bg-secondary-light', 'shadow-lg', 'scale-110');
          dot.style.borderColor = 'rgba(240, 230, 224, 0.8)';
        } else {
          dot.classList.remove('bg-secondary-light', 'shadow-lg', 'scale-110');
          dot.classList.add('bg-secondary-light/20');
          dot.style.borderColor = 'rgba(240, 230, 224, 0.3)';
        }
      });
    }

    // Initialize after DOM is fully loaded
    setTimeout(() => {
      calculateSectionOffsets();
      updateProgressDots();
    }, 100);

    // Scroll event listener
    scrollContainer.addEventListener('scroll', updateProgressDots);

    // Enhanced wheel event for smooth section transitions
    scrollContainer.addEventListener('wheel', function(e) {
      e.preventDefault();
      const delta = e.deltaY;
      const scrollTop = scrollContainer.scrollTop;
      const currentSection = getCurrentSection(scrollTop);
      
      if (delta > 0 && currentSection < totalSections - 1) {
        // Scroll down to next section
        const nextSection = sectionElements[currentSection + 1];
        if (nextSection) {
          scrollContainer.scrollTo({
            top: nextSection.offsetTop,
            behavior: 'smooth'
          });
        }
      } else if (delta < 0 && currentSection > 0) {
        // Scroll up to previous section
        const prevSection = sectionElements[currentSection - 1];
        if (prevSection) {
          scrollContainer.scrollTo({
            top: prevSection.offsetTop,
            behavior: 'smooth'
          });
        }
      }
    });

    // Click on dots to navigate to sections
    dots.forEach((dot, index) => {
      dot.addEventListener('click', () => {
        const targetSection = sectionElements[index];
        if (targetSection) {
          scrollContainer.scrollTo({
            top: targetSection.offsetTop,
            behavior: 'smooth'
          });
        }
      });
      
      // Add hover effects
      dot.addEventListener('mouseenter', () => {
        if (!dot.classList.contains('bg-secondary-light')) {
          dot.style.transform = 'scale(1.1)';
          dot.style.backgroundColor = 'rgba(240, 230, 224, 0.4)';
        }
      });
      
      dot.addEventListener('mouseleave', () => {
        if (!dot.classList.contains('bg-secondary-light')) {
          dot.style.transform = 'scale(1)';
          dot.style.backgroundColor = 'rgba(240, 230, 224, 0.2)';
        }
      });
    });

    // Recalculate offsets on window resize
    window.addEventListener('resize', () => {
      setTimeout(() => {
        calculateSectionOffsets();
        updateProgressDots();
      }, 100);
    });
  });
</script> 